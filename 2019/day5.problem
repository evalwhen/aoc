这是对 **Advent of Code** 第 5 天题目描述的如实翻译：

---

### 第 5 天：晴转小行星

当飞船向水星进发时，你开始流汗了。精灵们建议你通过升级飞船电脑以支持“热环境监督终端”（Thermal Environment Supervision Terminal，简称 TEST），从而让空调重新运转。

热环境监督终端（TEST）首先会运行一个诊断程序（即你的谜题输入）。TEST 诊断程序将在你现有的 Intcode 计算机上运行，但需要进行一些修改：

**首先，你需要增加两条新指令：**

* **操作码 3** 接收一个整数作为**输入**，并将其保存到其唯一参数指定的位置。例如，指令 `3,50` 会获取一个输入值并将其存储在地址 50。
* **操作码 4** **输出**其唯一参数的值。例如，指令 `4,50` 会输出地址 50 处的值。

使用这些指令的程序会附带文档，说明输入和输出应该连接到哪里。程序 `3,0,4,0,99` 会输出它接收到的任何输入，然后停机。

**其次，你需要增加对参数模式（parameter modes）的支持：**

指令的每个参数都是根据其参数模式来处理的。目前，你的飞船电脑已经理解**参数模式 0**，即**位置模式（position mode）**，这意味着参数被解释为一个位置——如果参数是 50，它的值就是存储在内存地址 50 处的值。到目前为止，所有参数都处于位置模式。

现在，你的飞船电脑还需要处理**模式 1** 的参数，即**立即模式（immediate mode）**。在立即模式下，参数被解释为一个数值——如果参数是 50，它的值就是 50。

参数模式存储在与指令操作码相同的数值中。操作码是一个两位数，仅基于该数值的个位和十位，也就是说，操作码是指令中第一个数值的最右边两位数字。参数模式是单个数字，每个参数一个，从操作码向左读取：第一个参数的模式在百位，第二个参数的模式在千位，第三个参数的模式在万位，依此类推。任何缺失的模式都默认为 0。

例如，考虑程序 `1002,4,3,4,33`。

第一条指令 `1002,4,3,4` 是乘法指令——第一个数值的最右边两位 `02` 表示操作码 2，即乘法。然后，从右向左看，参数模式分别是 0（百位）、1（千位）和 0（万位，不存在因此为零）：

```text
ABCDE
 1002

DE - 两位操作码，      02 == 操作码 2
 C - 第 1 个参数的模式，0 == 位置模式
 B - 第 2 个参数的模式，1 == 立即模式
 A - 第 3 个参数的模式，0 == 位置模式，
                          由于是前导零所以省略了

```

这条指令将其前两个参数相乘。第一个参数是 `4`（位置模式），运作方式和以前一样——它的值是存储在地址 4 的值（33）。第二个参数是 `3`（立即模式），其值就是 3。这次运算的结果 `33 * 3 = 99`，根据第三个参数 `4`（位置模式）进行写入，其运作方式也和以前一样——将 99 写入地址 4。

**指令写入目标的参数永远不会处于立即模式。**

**最后，一些注意事项：**

* 务必记住，指令执行完毕后，指令指针（instruction pointer）增加的量应等于该指令中数值的个数。因为有了新指令，这个增加量不再总是 4。
* 整数可以是负数：`1101,100,-1,4,0` 是一个合法的程序（计算 100 + -1，将结果存储在位置 4）。
* TEST 诊断程序开始运行时，会通过执行一条输入指令来请求用户提供待测试系统的 ID——请提供 **1**，这是飞船空调单元的 ID。
* 然后它将执行一系列诊断测试，确认 Intcode 计算机的各个部分（如参数模式）是否正常工作。对于每个测试，它都会运行一条输出指令，指示测试结果与预期值的偏差，其中 **0** 表示测试成功。非零输出意味着某个功能工作不正常；请检查在该输出指令之前运行的指令，看看是哪里出了问题。
* 最后，程序将输出一个诊断代码并立即停机（halt）。最后的这个输出不是错误；输出后紧接着停机意味着程序已结束。如果除了诊断代码之外的所有输出都是零，则说明诊断程序运行成功。

在为唯一的输入指令提供 **1** 并通过所有测试后，程序产生的诊断代码是多少？

--- 第二部分 ---

空调上线了！冷风吹了一会儿感觉不错，但随后 TEST 警报开始响起。因为空调无法将热量排到飞船外部，只能排回飞船内部，所以它实际上让飞船内的空气更热了。

相反，你需要使用 TEST 来展开散热器。幸运的是，诊断程序（你的谜题输入）已经为此做好了准备。但不幸的是，你的 Intcode 计算机还没有。

你的计算机只缺少几个操作码：

    操作码 5 是**“若真跳转” (jump-if-true)：如果第一个参数非零**，它将指令指针设置为第二个参数的值。否则，它什么也不做。

    操作码 6 是**“若假跳转” (jump-if-false)：如果第一个参数为零**，它将指令指针设置为第二个参数的值。否则，它什么也不做。

    操作码 7 是**“小于” (less than)：如果第一个参数小于**第二个参数，它将 1 存储在第三个参数给出的位置。否则，它存储 0。

    操作码 8 是**“等于” (equals)：如果第一个参数等于**第二个参数，它将 1 存储在第三个参数给出的位置。否则，它存储 0。

像所有指令一样，这些指令需要支持如上所述的参数模式。

通常，指令完成后，指令指针会增加该指令中值的数量。但是，如果指令修改了指令指针，则使用该新值，并且指令指针不会自动增加。

例如，这里有几个程序，它们接受一个输入，将其与值 8 进行比较，然后产生一个输出：

    3,9,8,9,10,9,4,9,99,-1,8 - 使用位置模式，判断输入是否等于 8；输出 1（如果是）或 0（如果不是）。

    3,9,7,9,10,9,4,9,99,-1,8 - 使用位置模式，判断输入是否小于 8；输出 1（如果是）或 0（如果不是）。

    3,3,1108,-1,8,3,4,3,99 - 使用立即模式，判断输入是否等于 8；输出 1（如果是）或 0（如果不是）。

    3,3,1107,-1,8,3,4,3,99 - 使用立即模式，判断输入是否小于 8；输出 1（如果是）或 0（如果不是）。

这里有一些跳转测试，接受一个输入，如果输入为零则输出 0，如果输入非零则输出 1：

    3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9 (使用位置模式)

    3,3,1105,-1,9,1101,0,0,12,4,12,99,1 (使用立即模式)

这里有一个更大的例子：

3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31, 1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104, 999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99

上面的示例程序使用输入指令请求单个数字。如果输入值低于 8，程序将输出 999；如果输入值等于 8，输出 1000；如果输入值大于 8，输出 1001。

这一次，当 TEST 诊断程序运行其输入指令以获取要测试的系统 ID 时，提供 5，这是飞船散热器控制器的 ID。该诊断测试套件仅输出一个数字，即诊断代码。

系统 ID 5 的诊断代码是多少？
